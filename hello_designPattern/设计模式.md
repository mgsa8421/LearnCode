# 简单工厂模式
* 作用
一个基类派生出几个重写了同一方法的派生类，在实际调用这些派生类的方法时，需要先创建相应派生类的对象。根据一些条件创建相应的对象，就是简单工厂模式干的活。
实例
实现一个简单的计算器
每个计算器都需要三个数据，两个操作数和一个运算符号
首先创建一个operate类，包含两个操作数属性
然后从 operate继承出加减乘除四个类，它们对父类的计算数值方法（父类中定义为虚函数）进行重写
然后在创建一个工厂类，根据输入进的操作符不同，new出不同的加减乘除类，调用它们的计算数值方法                      
这样做的好处是
如果需要添加新的运算符号，如乘方等，不需要修改原有的代码，只需要再添加一个加减乘除类，并在工厂中添加相应的new即可

# 继承和多态
创建一个对象的两种方式
* 直接创建
* 间接创建，通过指针创建（类似创建一种数据类型的指针，int* float*这样），指针指向对象的地址（这个地址的内存空间是怎么样的的？）

对于一个类的成员（ 无论是类方法还是属性）分为两种访问方式（从访问者的角度来说），因此产生了访问权限控制public、protect、private（注意继承方式也有这三种，但并不是同一个概念）
* 类内方法访问，类方法中可以访问任意的类成员，无论是何种访问权限控制符
* 类外对象访问，就是类创建的对象（例如在main函数中，实例化一个的class Student，叫xiaoming），它虽然持有了所有的实例化出的成员实体，但是对于protect和private都是无法访问的
以上是对于类自身的情况，现在加上继承

首先一般简单的继承会怎么用呢？
* 父类包括一个或若干个纯虚函数（函数值定义为0），那么就是抽象类，它无法实例化，必须派生出子类对其纯虚函数进行实现
* 父类包含虚函数
* 父类不包含虚函数
对于继承自父类的子类，会怎么继承呢？
* 重写（实现）父类的纯虚函数
* 重写父类的虚函数
* 重写父类的已有函数
* 扩展父类没有的函数
对于上述子类的函数，在具体调用时，何时是调用父类的函数，何时又是调用子类的函数呢，如何进行控制？

对于父类的访问控制权限，对于派生类会产生什么效果？

关于构造函数和析构函数的问题
父子类的构造与析构
* 首先，创建和销毁子类时，父类的构造函数和析构函数必然会被依次调用
* 构造函数不可被声明为virtual，但析构函数可以
* 通过父类指针创建的子类对象，构造函数会去调用父类的构造函数，而不会去用子类的；如果想用子类的构造函数，可以两种方式：一是，通过直接创建子类对象的方式（不通过父类指针）；二是，使用子类自身的指针new一个对象出来
* 析构函数可以为虚函数，因此即使父类创建出的子类对象，只要对析构函数做了重写，子类析构函数也会被调用

```cpp

```

